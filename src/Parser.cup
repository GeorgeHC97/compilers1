import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory;

parser code{:
	public boolean syntaxErrors = false;
	public void syntax_error(Symbol current_token) {
		syntaxErrors = true;
		report_error(
			"Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null
		);
	}
:}




terminal IDENTIFIER; 
terminal BOOLEAN, CHARACTER, INTEGER, RATIONAL, STRING; 
terminal CHAR, BOOL, INT, RAT, FLOAT, TOP, DICT, SEQ;
terminal TDEF, FDEF, ALIAS, MAIN, VOID;
terminal PLUS, MINUS, DIVIS, MULTI, POW, ASSIGN;
terminal AND, OR, EQUAL, NOTEQUAL, NOT, LESS, LESSEQUAL, IMPLIES;
terminal IF,ELSE,ELIF,THEN,FI,WHILE, DO,OD,FORALL,IN, RETURN;
terminal READ, PRINT;
terminal LBRACE, RBRACE, LPAREN, RPAREN, SEMICOLON, LBRACK, RBRACK, MORESIGN, COMMA, DOT, COLON;
terminal CAT, LEN;
terminal BADCHAR, FLOAT_LIT;

non terminal GlobalStatements, Main, GlobalStatements1;
non terminal Epsilon, DICTSEQTYPE;
non terminal DataType, ReturnType, DataValue, VariableDeclare, VariableAssignment, Assignment;
non terminal BooleanOperators, NumericOperators, BooleanCompare, NumericCompare;
non terminal DictSeqOperator;
non terminal SeqOperator, SeqExpression, SeqExpression1, SeqExpression2;
non terminal ConcatVar, Concat, ConcatExtension, ConcatList;
non terminal BooleanExpression, MathsExpression, Expressions;
non terminal MainReturn, Statements, Parameters, Parameters1,Parameters2;
non terminal DictDeclare, DictDeclareID, Dictionary, DictValues, DictValues1, DictionaryList, DictionaryNest;
non terminal SeqDeclare, SeqDeclareID, Sequence, SeqValues,SeqValues1, SequenceList, SequenceNest, SeqListExtension;
non terminal Alias, NameType, NewDataType, DeclarationList, DecListExtension;
non terminal IfStatement, IfExtenstion, WhileLoop, ForLoop, Read, Print, FunctionCall, FuncParamList, FuncParamListExtend, Function, Body, DictListExtension,SequenceList1,SequenceList2,SequenceLis3,FuncParamList1;

non terminal Parentheses, LengthSeq, FuncParamTypes;
non terminal NewTypeAssign, NewTypeAssign1, NewTypeAssign2;
non terminal SeqOperator1, SeqOperator2, Assignment1, Assignment2;
non terminal AllDataValues, StatementsWithOutEpsilon;


precedence left MINUS;
precedence left PLUS;
precedence left DIVIS;
precedence left MULTI;
precedence left COMMA;
precedence left OR;
precedence left AND;
precedence left IMPLIES;
precedence left NOT;
precedence left NOTEQUAL;
precedence left EQUAL;
precedence left IDENTIFIER;
precedence left LESSEQUAL;
precedence left LESS;
precedence left IN;
precedence left CAT;
precedence left POW;
precedence left RPAREN;
precedence left LPAREN;
precedence left ASSIGN;

//Where the parser begins
start with GlobalStatements;



GlobalStatements ::= GlobalStatements1 Main GlobalStatements1;
//any of these can be declared outside the main		
GlobalStatements1 ::= Function GlobalStatements1 
			| VariableDeclare GlobalStatements1 
			|NewDataType GlobalStatements1 
			|Alias GlobalStatements1 
			|Dictionary GlobalStatements1 
			|Sequence GlobalStatements1 
			|Epsilon;
					
Epsilon ::=     ;

//Main Stuff
Main ::= MAIN LBRACE StatementsWithOutEpsilon RBRACE SEMICOLON; 
MainReturn ::= RETURN Expressions SEMICOLON | RETURN SEMICOLON;
Body ::= Statements;
StatementsWithOutEpsilon ::= FunctionCall SEMICOLON Statements | 
		VariableDeclare Statements | 
		NewDataType Statements |
		Alias Statements |
		Dictionary Statements |
		Sequence Statements |
		IfStatement Statements |
		WhileLoop Statements |
		ForLoop Statements |
		Read Statements |
		Print Statements| 
		Assignment Statements |
		MainReturn;
Statements ::=  StatementsWithOutEpsilon |Epsilon;


//DataTypes
DataType ::= CHAR|BOOL|INT|RAT|FLOAT|TOP|IDENTIFIER;
ReturnType ::= VOID|DataType|SeqDeclare|DictDeclare;
DataValue ::= CHARACTER|BOOLEAN|INTEGER|RATIONAL|FLOAT_LIT|STRING|IDENTIFIER;
AllDataValues ::= DataValue | SeqValues | DictValues;

VariableDeclare ::= DataType IDENTIFIER VariableAssignment SEMICOLON;
VariableAssignment ::= ASSIGN Assignment2 | Epsilon;  

Assignment ::= Assignment1 ASSIGN Assignment2 SEMICOLON;
Assignment1 ::= IDENTIFIER | IDENTIFIER DOT IDENTIFIER; 
Assignment2 ::= NewTypeAssign |Expressions;

/*Operators*/
BooleanOperators ::= AND | OR | IMPLIES;
NumericOperators ::= PLUS|MINUS|MULTI|DIVIS|POW;
BooleanCompare ::= EQUAL | NOTEQUAL;
NumericCompare ::= BooleanCompare | LESS | LESSEQUAL;

//DictSeqValues ::= IDENTIFIER | DictValues | SeqValues;
//DictSeqID ::= IDENTIFIER | INTEGER;  //Assuming you can also have a predefined variable
DictSeqOperator ::= Expressions IN Expressions; //| LEN LBRACK DictSeqID RBRACK; //Not Complete
//DictOperator ::= IDENTIFIER LBRACK Expressions RBRACK;  //Not Complete



SeqOperator ::= IDENTIFIER SeqOperator1;
SeqOperator1 ::= LBRACK SeqExpression RBRACK SeqOperator2;
SeqOperator2 ::= SeqOperator1 | Epsilon;
SeqExpression ::= Expressions SeqExpression1 | COLON Expressions;
SeqExpression1 ::= COLON SeqExpression2 | Epsilon;
SeqExpression2 ::= Expressions | Epsilon;

DICTSEQTYPE::= DataType | DictDeclare | SeqDeclare;
/*Dictionary and Sequences*/
DictDeclare ::= DICT LESS DICTSEQTYPE COMMA DICTSEQTYPE MORESIGN;
DictDeclareID ::= DictDeclare IDENTIFIER;
Dictionary ::= DictDeclareID ASSIGN DictValues1; 
DictValues1 ::= DictValues SEMICOLON | FunctionCall SEMICOLON; 
DictValues ::= LBRACE DictionaryList RBRACE;
DictionaryList ::= DataValue COLON DataValue DictListExtension | DictionaryNest | Epsilon;
DictionaryNest ::= DictValues DictListExtension;
DictListExtension ::= COMMA DictionaryList | Epsilon;

SeqDeclare ::= SEQ LESS DICTSEQTYPE MORESIGN;
SeqDeclareID ::= SeqDeclare IDENTIFIER;
Sequence ::= SeqDeclareID ASSIGN SeqValues1;
SeqValues1 ::= SeqValues SEMICOLON | FunctionCall SEMICOLON |Concat SEMICOLON; 
SeqValues ::= LBRACK SequenceList RBRACK ;
SequenceList ::= SequenceList2 | SequenceList1 | SequenceNest | ;
SequenceList2 ::= DataValue SeqListExtension;
SequenceList1 ::= MINUS DataValue SeqListExtension ;
SequenceNest ::= SeqValues SeqListExtension;
SeqListExtension ::= COMMA SequenceList | Epsilon;


/*End - Dictionary and Sequences*/
              

ConcatVar ::= IDENTIFIER | IDENTIFIER DOT IDENTIFIER |SeqValues | SeqOperator; 
Concat ::= ConcatVar ConcatExtension ; 
ConcatExtension ::= CAT ConcatVar ConcatList;
ConcatList ::= ConcatExtension | Epsilon;

BooleanExpression ::= Expressions NumericCompare Expressions | 
		NOT Expressions | 
		Expressions BooleanOperators Expressions ;
MathsExpression ::= Expressions NumericOperators Expressions| MINUS Expressions;
Parentheses ::= LPAREN Expressions RPAREN;
LengthSeq ::= LEN Parentheses;

Expressions ::= MathsExpression|
		BooleanExpression|
		Concat |
		FunctionCall |  
		DataValue|
		IDENTIFIER DOT IDENTIFIER|
		Parentheses|
		LengthSeq|
		SeqOperator|		
		DictSeqOperator;

		

			  

//Function Declaration
Function ::= FDEF ReturnType IDENTIFIER LPAREN Parameters RPAREN LBRACE Statements RBRACE SEMICOLON;
FuncParamTypes ::= DataType | DictDeclare | SeqDeclare;
Parameters ::= FuncParamTypes IDENTIFIER Parameters1|  Epsilon; //Need to check how to do epsilon (null) 
Parameters1 ::= COMMA Parameters2 | Epsilon;
Parameters2 ::= FuncParamTypes IDENTIFIER Parameters1;
//Function Call
FunctionCall ::= IDENTIFIER LPAREN FuncParamList RPAREN ;
FuncParamList ::= Expressions FuncParamListExtend | Epsilon;
FuncParamListExtend ::= COMMA FuncParamList1 | Epsilon;
FuncParamList1::= Expressions FuncParamListExtend;

//Alias
Alias ::= ALIAS NameType IDENTIFIER SEMICOLON;
/*NameType ::= DataType | IDENTIFIER | DictDeclare | SeqDeclare; */
NameType ::= DataType | DictDeclare | SeqDeclare;
NewDataType ::= TDEF IDENTIFIER LBRACE DeclarationList RBRACE SEMICOLON;
DeclarationList ::=  NameType IDENTIFIER DecListExtension;
DecListExtension ::= COMMA DeclarationList | Epsilon;


NewTypeAssign ::= AllDataValues NewTypeAssign1;
NewTypeAssign1 ::= COMMA AllDataValues NewTypeAssign2;
NewTypeAssign2 ::= NewTypeAssign1 | Epsilon;

/*Program Flow*/
IfStatement ::= IF LPAREN Expressions RPAREN THEN  Body IfExtenstion FI;
IfExtenstion ::= ELSE Body | ELIF LPAREN Expressions RPAREN THEN Body IfExtenstion | Epsilon;
WhileLoop ::= WHILE LPAREN Expressions RPAREN DO Body OD;
ForLoop ::= FORALL LPAREN Expressions IN Expressions RPAREN DO Body OD; //Edited this not sure


//I/O
Read ::= READ IDENTIFIER SEMICOLON;
Print ::= PRINT Expressions SEMICOLON;

